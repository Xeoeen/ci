macro_rules! eprint_flush {
	($fmt:expr $(,$arg:expr)*) => {
		{
			use std;
			use std::io::Write;
			eprint!($fmt $(,$arg)*);
			std::io::stderr().flush().unwrap();
		}
	};
}

pub mod human;
pub mod json;
pub mod none;

use failure;
use std;

pub fn timefmt(t: std::time::Duration) -> String {
	format!("{}.{:02}s", t.as_secs(), t.subsec_nanos() / 10_000_000)
}

pub trait Ui {
	fn read_auth(&mut self, domain: &str) -> (String, String);
	fn track_progress(&mut self, status: &commands::tracksubmit::Status);
	fn submit_success(&mut self, id: String);
	fn print_resource_list(&mut self, resources: &[commands::list_resources::Resource]);
	fn print_resource(&mut self, data: &[u8]);
	fn print_test(&mut self, outcome: &TestResult, timing: Option<Duration>, in_path: &Path, output: Option<StrRes>);
	fn print_finish_test(&mut self, success: bool);
	fn print_transpiled(&mut self, compiled: &str);
	fn print_found_test(&mut self, test_str: &str);
	fn print_error(&mut self, error: failure::Error);
	fn mt_generator_fail(&mut self, i: i64);
	fn mt_autogenerated(&mut self, i: i64);
	fn mt_good(&mut self, t: Duration);
	fn mt_bad(&mut self, t: Duration);
	fn mt_piece(&mut self, result: &TestResult, ti: Duration);
	fn mt_piece_ignored(&mut self);
	fn mt_piece_finish(&mut self);
	fn warn(&mut self, message: &str);
	fn notice(&mut self, message: &str);
}

pub use self::{human::Human, json::Json};
use commands;
use std::{path::Path, time::Duration};
use strres::StrRes;
use testing::TestResult;
